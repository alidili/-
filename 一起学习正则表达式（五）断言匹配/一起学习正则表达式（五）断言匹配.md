# 0.写在前面

一提到断言，很多人第一时间就会想到单元测试，在正则中，断言是指对匹配到的文本位置有要求，比如我们想要查找一段文本中 tom 这个单词，但是其他单词 tomorrow 或者 tomato 也包含 tom，我们该怎么去限定呢，这就是断言大显身手的时候了。

对匹配到的文本位置有要求，其实就是限定单词左边和右边的字符类型，细想下来，其实和单元测试中的断言也差不多，正则中常见的断言有三种，分别是单词边界、行的开始和结束、环视，一起来看下。

# 1.单词边界

我们在第三篇文章中，学习了正则中分组与引用的知识，其中在查找那一节，我们举了一个例子，来回顾下：

有这样一个需求，在一个目标字符串中，查找两个重复出现的单词，还没有学到单词边界，我们先用 **\w{2,}** 来表示出现的单词，重复的单词就是 **(\w{2,} \1)**，看下结果：

![分组查找](https://github.com/alidili/Regex/raw/main/%E4%B8%80%E8%B5%B7%E5%AD%A6%E4%B9%A0%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88%E4%BA%94%EF%BC%89%E6%96%AD%E8%A8%80%E5%8C%B9%E9%85%8D/resources/%E5%88%86%E7%BB%84%E6%9F%A5%E6%89%BE.png)

有的同学会有疑问，为什么要用 \w{2,} 来表示一个单词呢，\w+ 不行吗，来看下 \w+ 匹配的效果：

![分组查找 \w+](https://github.com/alidili/Regex/raw/main/%E4%B8%80%E8%B5%B7%E5%AD%A6%E4%B9%A0%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88%E4%BA%94%EF%BC%89%E6%96%AD%E8%A8%80%E5%8C%B9%E9%85%8D/resources/%E5%88%86%E7%BB%84%E6%9F%A5%E6%89%BE%20w%2B.png)

可以看到字母 s 也被匹配到了，这并不是我们想要的结果，我们需要优雅的解决这个问题，就用到了单词边界，边界的英文是 Boundary，取其首字母小写，就用 **\b** 来表示，可以写在单词的左边或右边，修改之后是这样的：

![单词边界](https://github.com/alidili/Regex/raw/main/%E4%B8%80%E8%B5%B7%E5%AD%A6%E4%B9%A0%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88%E4%BA%94%EF%BC%89%E6%96%AD%E8%A8%80%E5%8C%B9%E9%85%8D/resources/%E5%8D%95%E8%AF%8D%E8%BE%B9%E7%95%8C.png)

**\b** 放在单词的左边或者右边，匹配结果是不一样的：

单词 | tom<br>单词包含 tom | \btom<br>以 tom 开头的单词 | tom\b<br>以 tom 结尾的单词 | \btom\b<br>只能是 tom
:-: | :-: | :-: | :-: | :-:
tom | ✔ | ✔ | ✔ | ✔
tomorrow | ✔ | ✔ | ✘ | ✘
atom | ✔ | ✘ | ✔ | ✘
atomic | ✔ | ✘ | ✘ | ✘

# 2.行的开始和结束

在前几篇文章中，我们已经对行的开始和结束标记有一些了解了，在正则中，我们使用脱字符 **^** 来表示行的开始，美元符 **$** 来表示行的结尾，举个栗子：

对登录密码进行格式校验，密码要求是6位连续的数字，我们可以很快的写出正则表达式 **\d{6}**，来验证下：

![密码校验](https://github.com/alidili/Regex/raw/main/%E4%B8%80%E8%B5%B7%E5%AD%A6%E4%B9%A0%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88%E4%BA%94%EF%BC%89%E6%96%AD%E8%A8%80%E5%8C%B9%E9%85%8D/resources/%E5%AF%86%E7%A0%81%E6%A0%A1%E9%AA%8C.png)

可以看到6位数字可以匹配成功，7位、8位也可以匹配成功，这显然是不对的，修改下：

![密码校验，开始结束限定](https://github.com/alidili/Regex/raw/main/%E4%B8%80%E8%B5%B7%E5%AD%A6%E4%B9%A0%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88%E4%BA%94%EF%BC%89%E6%96%AD%E8%A8%80%E5%8C%B9%E9%85%8D/resources/%E5%AF%86%E7%A0%81%E6%A0%A1%E9%AA%8C%EF%BC%8C%E5%BC%80%E5%A7%8B%E7%BB%93%E6%9D%9F%E9%99%90%E5%AE%9A.png)

和单词边界差不多，^ 限定以什么开始，$ 限定以什么结尾，只不过限定的不是单词，而是一段文本。

我们还可以使用 **\A** 和 **\z（Python 中使用 \Z）** 来限定行的开始和结束：

![密码校验，\A \Z 限定](https://github.com/alidili/Regex/raw/main/%E4%B8%80%E8%B5%B7%E5%AD%A6%E4%B9%A0%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88%E4%BA%94%EF%BC%89%E6%96%AD%E8%A8%80%E5%8C%B9%E9%85%8D/resources/%E5%AF%86%E7%A0%81%E6%A0%A1%E9%AA%8C%EF%BC%8CA%20Z%20%E5%8C%B9%E9%85%8D.png)

**注意：\A \Z 这种匹配方式是不支持多行模式的，目标字符串中也不可以有其他字符，比如换行或者空格。**

# 3.环视

环视在正则中的意思就是左右看，也被称为零宽断言，和单词边界类似，但是更加灵活了，环视可以限定单词的左边可以是什么类型，不可以是什么类型，单词的右边可以是什么类型，不可以是什么类型：

正则 | 名称 | 含义 | 示例
:-: | :-: | :-: | :-:
(?<=Y) | 肯定逆序环视 | 左边是Y | (?<=\d)th 左边是数字的 th，可以匹配上 9th
(?<!Y) | 否定逆序环视 | 左边不是Y | (?<!\d)th 左边不是数字的 th，可以匹配上 health
(?=Y) | 肯定顺序环视 | 右边是Y | six(?=\d) 右边是数字的 six，可以匹配上 six6
(?!Y) | 否定顺序环视 | 右边不是Y | six(?!\d) 右边不是数字的 six，可以匹配上 sixgod

**环视的正则表达式是用括号括起来的，注意这个括号不会被保存成子组，引用数括号位置的时候注意跳过。**

**这四个表达式，乍一看起来有点懵，其实是有规律可循的，带尖括号的看左边，不带尖括号的看右边，带叹号就是否定，这样就好记了。**

我们用环视来表示下上面学到的单词边界，可以这样写 **((?<!\w)\w+(?!\w))**：

![环视](https://github.com/alidili/Regex/blob/main/%E4%B8%80%E8%B5%B7%E5%AD%A6%E4%B9%A0%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88%E4%BA%94%EF%BC%89%E6%96%AD%E8%A8%80%E5%8C%B9%E9%85%8D/resources/%E7%8E%AF%E8%A7%86.png)

# 4.写在最后

最后在总结下上面讲到的内容：

![思维导图](https://github.com/alidili/Regex/raw/main/%E4%B8%80%E8%B5%B7%E5%AD%A6%E4%B9%A0%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88%E4%BA%94%EF%BC%89%E6%96%AD%E8%A8%80%E5%8C%B9%E9%85%8D/resources/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE.png)

到这里，正则表达式的断言匹配就讲完了，如果有问题可以给我留言评论，谢谢。

正则表达式在线校验工具：https://regex101.com/